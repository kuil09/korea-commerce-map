name: Platform Screenshot Preview

on:
  pull_request:
    paths:
      - 'data/platforms.yaml'

permissions:
  contents: write
  pull-requests: write

jobs:
  screenshot:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout PR branch
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Playwright
        run: |
          npm install playwright@1.49.1
          npx playwright install chromium --with-deps

      - name: Fetch base branch
        run: |
          git fetch origin ${{ github.base_ref }}

      - name: Detect new/modified platforms
        id: detect
        run: |
          mkdir -p screenshots
          node scripts/detect-new-platforms.js origin/${{ github.base_ref }} HEAD screenshots/platforms.json
          
          # Read the JSON file and set output
          if [ -f screenshots/platforms.json ]; then
            PLATFORMS=$(cat screenshots/platforms.json)
            # Check if array is empty
            if [ "$PLATFORMS" = "[]" ]; then
              echo "has_changes=false" >> $GITHUB_OUTPUT
            else
              echo "has_changes=true" >> $GITHUB_OUTPUT
            fi
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Capture screenshots
        if: steps.detect.outputs.has_changes == 'true'
        run: |
          cat screenshots/platforms.json | node scripts/capture-screenshots.js
        env:
          SCREENSHOTS_DIR: ./screenshots

      - name: Upload screenshots as artifact
        if: steps.detect.outputs.has_changes == 'true'
        uses: actions/upload-artifact@v4
        with:
          name: platform-screenshots
          path: screenshots/
          retention-days: 7

      - name: Create PR comment with screenshots
        if: steps.detect.outputs.has_changes == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            
            // GitHub comment bodyì˜ ìµœëŒ€ ê¸¸ì´ (65536ì)
            const MAX_BODY_LENGTH = 65536;
            
            // ê²°ê³¼ JSON ì½ê¸°
            const resultsPath = './screenshots/results.json';
            if (!fs.existsSync(resultsPath)) {
              console.log('No results file found');
              return;
            }
            
            const results = JSON.parse(fs.readFileSync(resultsPath, 'utf8'));
            
            if (results.length === 0) {
              console.log('No platforms to report');
              return;
            }
            
            // ì•„í‹°íŒ©íŠ¸ URL ìƒì„±
            const artifactUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${{ github.run_id }}`;
            
            /**
             * ìŠ¤í¬ë¦°ìƒ·ì„ GitHubì— ì—…ë¡œë“œí•˜ê³  URLì„ ë°˜í™˜
             * GitHubì˜ user-content CDNì— ì—…ë¡œë“œí•˜ì—¬ PR ì½”ë©˜íŠ¸ì— í‘œì‹œ ê°€ëŠ¥í•œ URL ìƒì„±
             * @param {string} filePath - ì´ë¯¸ì§€ íŒŒì¼ ê²½ë¡œ
             * @param {string} fileName - íŒŒì¼ ì´ë¦„
             * @returns {Promise<string|null>} ì—…ë¡œë“œëœ ì´ë¯¸ì§€ URL ë˜ëŠ” null
             */
            async function uploadScreenshot(filePath, fileName) {
              try {
                if (!fs.existsSync(filePath)) {
                  console.log(`File not found: ${filePath}`);
                  return null;
                }
                
                const imageData = fs.readFileSync(filePath);
                const base64Data = imageData.toString('base64');
                
                // GitHub APIë¥¼ í†µí•´ ì´ë¯¸ì§€ ì—…ë¡œë“œ (repository content API ì‚¬ìš©)
                // PR ë¸Œëœì¹˜ì— ìŠ¤í¬ë¦°ìƒ·ì„ ì»¤ë°‹í•˜ì—¬ raw URLë¡œ ì ‘ê·¼ ê°€ëŠ¥í•˜ê²Œ í•¨
                const prNumber = ${{ github.event.pull_request.number }};
                // PR ë²ˆí˜¸ ìœ íš¨ì„± ê²€ì¦ (ìˆ«ìë§Œ í—ˆìš©)
                if (!Number.isInteger(prNumber) || prNumber <= 0) {
                  console.log(`Invalid PR number: ${prNumber}`);
                  return null;
                }
                const screenshotBranch = `screenshots-pr-${prNumber}`;
                const screenshotPath = `screenshots/${fileName}`;
                
                // ë¸Œëœì¹˜ê°€ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                let branchExists = false;
                try {
                  await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: screenshotBranch
                  });
                  branchExists = true;
                } catch (e) {
                  branchExists = false;
                }
                
                // ë¸Œëœì¹˜ê°€ ì—†ìœ¼ë©´ ìƒì„±
                if (!branchExists) {
                  // ê¸°ë³¸ ë¸Œëœì¹˜ì˜ SHA ê°€ì ¸ì˜¤ê¸° (ê¸°ë³¸ê°’: main)
                  const defaultBranchName = '${{ github.event.repository.default_branch }}' || 'main';
                  const { data: defaultBranch } = await github.rest.repos.getBranch({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    branch: defaultBranchName
                  });
                  
                  await github.rest.git.createRef({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    ref: `refs/heads/${screenshotBranch}`,
                    sha: defaultBranch.commit.sha
                  });
                  console.log(`Created branch: ${screenshotBranch}`);
                }
                
                // íŒŒì¼ì´ ì´ë¯¸ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
                let existingSha = null;
                try {
                  const { data: existingFile } = await github.rest.repos.getContent({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    path: screenshotPath,
                    ref: screenshotBranch
                  });
                  existingSha = existingFile.sha;
                } catch (e) {
                  // íŒŒì¼ì´ ì—†ìŒ - ì •ìƒ
                }
                
                // íŒŒì¼ ìƒì„±/ì—…ë°ì´íŠ¸
                const commitMessage = `ğŸ“¸ Update screenshot: ${fileName}`;
                const params = {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  path: screenshotPath,
                  message: commitMessage,
                  content: base64Data,
                  branch: screenshotBranch
                };
                
                if (existingSha) {
                  params.sha = existingSha;
                }
                
                await github.rest.repos.createOrUpdateFileContents(params);
                
                // Raw URL ìƒì„± (ìºì‹œ ë¬´íš¨í™”ë¥¼ ìœ„í•œ íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€)
                const timestamp = Date.now();
                const rawUrl = `https://raw.githubusercontent.com/${context.repo.owner}/${context.repo.repo}/${screenshotBranch}/${screenshotPath}?t=${timestamp}`;
                console.log(`Uploaded: ${fileName} -> ${rawUrl}`);
                return rawUrl;
                
              } catch (error) {
                console.log(`Failed to upload ${fileName}: ${error.message}`);
                return null;
              }
            }
            
            // ëª¨ë“  ìŠ¤í¬ë¦°ìƒ· ì—…ë¡œë“œ
            const uploadedUrls = new Map();
            for (const result of results) {
              if (result.success && result.screenshotPath && fs.existsSync(result.screenshotPath)) {
                const fileName = `${result.id}.png`;
                const url = await uploadScreenshot(result.screenshotPath, fileName);
                if (url) {
                  uploadedUrls.set(result.id, url);
                }
              }
            }
            
            console.log(`Uploaded ${uploadedUrls.size} screenshots`);
            
            /**
             * ë§ˆí¬ë‹¤ìš´ ìƒì„± (ì—…ë¡œë“œëœ URL ì‚¬ìš©)
             * @returns {string} ë§ˆí¬ë‹¤ìš´ ë¬¸ìì—´
             */
            function generateBody() {
              let body = '## ğŸ“¸ í”Œë«í¼ ìŠ¤í¬ë¦°ìƒ· ë¯¸ë¦¬ë³´ê¸°\n\n';
              body += '> ì•„ë˜ëŠ” PRì—ì„œ ì¶”ê°€/ë³€ê²½ëœ í”Œë«í¼ì˜ ì‹¤ì œ ì›¹ì‚¬ì´íŠ¸ í™”ë©´ì…ë‹ˆë‹¤.\n';
              body += `> ìŠ¤í¬ë¦°ìƒ·ì€ [GitHub Actions ì•„í‹°íŒ©íŠ¸](${artifactUrl})ì—ì„œë„ ë‹¤ìš´ë¡œë“œí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.\n\n`;
              
              for (const result of results) {
                const changeLabel = result.changeType === 'added' ? 'ğŸ†• ì‹ ê·œ ì¶”ê°€' : 'ğŸ”„ URL ë³€ê²½';
                
                body += `### ${result.name} (${result.nameEn})\n\n`;
                body += `| í•­ëª© | ë‚´ìš© |\n`;
                body += `|------|------|\n`;
                body += `| ë³€ê²½ ìœ í˜• | ${changeLabel} |\n`;
                body += `| URL | ${result.url} |\n`;
                
                if (result.success) {
                  body += `| ìƒíƒœ | âœ… ìº¡ì²˜ ì„±ê³µ |\n\n`;
                  
                  // ì—…ë¡œë“œëœ URLì´ ìˆìœ¼ë©´ ì´ë¯¸ì§€ í‘œì‹œ
                  const imageUrl = uploadedUrls.get(result.id);
                  if (imageUrl) {
                    body += `<details>\n<summary>ğŸ“· ìŠ¤í¬ë¦°ìƒ· ë³´ê¸° (í´ë¦­í•˜ì—¬ í¼ì¹˜ê¸°)</summary>\n\n`;
                    body += `![${result.name}](${imageUrl})\n\n`;
                    body += `</details>\n\n`;
                  }
                } else {
                  body += `| ìƒíƒœ | âŒ ìº¡ì²˜ ì‹¤íŒ¨ |\n`;
                  body += `| ì˜¤ë¥˜ | ${result.error} |\n\n`;
                }
                
                body += '---\n\n';
              }
              
              return body;
            }
            
            const body = generateBody();
            
            // ê¸°ì¡´ ì½”ë©˜íŠ¸ ì°¾ê¸°
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('ğŸ“¸ í”Œë«í¼ ìŠ¤í¬ë¦°ìƒ· ë¯¸ë¦¬ë³´ê¸°')
            );
            
            /**
             * ì½”ë©˜íŠ¸ë¥¼ ìƒì„±í•˜ê±°ë‚˜ ì—…ë°ì´íŠ¸í•˜ëŠ” í•¨ìˆ˜
             * @param {string} commentBody - ì½”ë©˜íŠ¸ ë³¸ë¬¸
             */
            async function postComment(commentBody) {
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
                console.log('Updated existing comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: commentBody
                });
                console.log('Created new comment');
              }
            }
            
            try {
              await postComment(body);
            } catch (error) {
              console.log(`Error posting comment: ${error.message}`);
              console.log('Screenshots are available in artifacts');
            }

      - name: No changes comment
        if: steps.detect.outputs.has_changes == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            console.log('No new or modified platforms detected. Skipping screenshot comment.');
